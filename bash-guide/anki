[latex]How can you explicitly specify indices when defining an array?[/latex]	[latex]Like so\\\texttt{names=([0]=``Bob'' [1]=``Peter'' [20]=``\$USER'' [21]=``Big Bad John'')}\\ or \texttt{names[0]=``Bob''}[/latex]
[latex]What does \texttt{``\${!arrayname[@]}''} expand into?[/latex]	[latex]The list of the indices of an array, in sequential order (or list of keys in an associative array, in an unpredictable order)[/latex]
[latex]How can you reindex a sparse array to remove all gaps?[/latex]	[latex]\texttt{array=(``\${array[@]}'')}[/latex]
[latex]How can you create a sparse array?[/latex]	[latex]By unsetting an index (use quotes!) or by specifically assigning to indices\\\texttt{nums=(zero one two three four)\\nums[70]=``seventy''\\unset `nums[3]'\\declare -p nums\\declare -a nums='([0]=``zero'' [1]=``one'' [2]=``two'' [4]=``four'' [70]=``seventy'')'}[/latex]
[latex]How do you create an associative array?[/latex]	[latex]Like:\\\texttt{declare -A fullNames\\fullNames=( [``lhunath'']=``Maarten Billemont'' [``greycat'']=``Greg Wooledge'' )}[/latex]
[latex]What is a File Descriptor?[/latex]	[latex]File descriptors are the way programs refer to files, or to other resources that work like files (such as pipes, devices, sockets, or terminals). When something reads from or writes to that FD, the data is read from or written to that FD's resource.[/latex]
[latex]What are the default FD's open to every new process?[/latex]	[latex]\begin{itemize}\item Standard Input (stdin): File Descriptor 0 \item Standard Output (sdout): File Descriptor 1\item Standard Error (stderr): File Descriptor 2\end{itemize}[/latex]
[latex]How can you redirect stderr to a file?[/latex]	[latex]Redirect with \texttt{2>}, e.g.\ \texttt{rm \$file 2>} errors[/latex]
[latex]How can you silence a file descriptor?[/latex]	[latex]By redirecting it to \texttt{/dev/null} e.g.\\\texttt{for homedir in /home/*\\ do rm ``\$homedir/secret''\\done 2> /dev/null}[/latex]
[latex]How can you append to a file rather than overwriting it?[/latex]	[latex]Double the redirection operator (i.e.\ use >> instead of >)[/latex]
[latex]How would you write both stdout and stderr to a file?[/latex]	[latex]Duplicate file descriptors with the \texttt{>\&} syntax e.g.\ \texttt{grep proud file `not a file' > proud.log 2>\&1}. Remember that file redirections are always read from left to right. Also, redirect to the file first, otherwise the stderr output will end up on the terminal. Bash has \texttt{\&>} as shorthand for \texttt{2>\&1}, but this is not recommended because it is not portable to sh[/latex]
[latex]What is a heredoc?[/latex]	[latex]Bash's multiline string syntax. Start the string with \textless\textless WORD and end it on a line that contains only WORD with no leading spaces (WORD can be arbitrary). Use \textless\textless- instead of \textless\textless to remove any tab characters at the beginning of each line.[/latex]
[latex]How can you disable parameter expansion in a heredoc?[/latex]	[latex]Quote the word that you use to delimit the heredoc (only the leading delimiter needs to be quoted)\\\texttt{cat <<`XYZ'\\My home directory is \$HOME\\XYZ}[/latex]
[latex]What are Herestrings?[/latex]	[latex]Strings with the \texttt{<<<} syntax that can be passed through stdin.\ e.g.\ \texttt{grep proud <<<``I am a proud sentence''}. Useful to send data in variables to processes. Prefer this to using echo and then piping. (not portable to sh)[/latex]
[latex]What is a FIFO in bash, and how do you make one?[/latex]	[latex]A FIFO is a named pipe that serves data on a first in, first out basis. When you read from a FIFO, you will only receive data when another process writes to it. (FIFOs are blocking queues on both reads and writes). It is created with the \texttt{mkfifo} command.[/latex]
[latex]What is process substitution?[/latex]	[latex]The <() creates a named pipe that contains the command's output. The operator itself in your command is replaced by the filename of that file. Afterwards, the file is cleaned up. For example, suppose you want to compare the output of two different commands\\head -n 1 .dictionary > file1\\tail -n 1 .dictionary > file2\\diff -y file1 file2\\With process substitution, you could do this like\\diff -y <(head -n 1 .dictionary) <(tail -n 1 .dictionary)\\These can be great for commands like diff that require filenames as input[/latex]
[latex]What does \textgreater(..) do?[/latex]	[latex]Instead of redirecting the command's output to a file, \textgreater(..) will redirect the file to the command's input. It's used for cases where you're running a command that writes to a file, but you want it to write to another command instead:\\tar -cf \textgreater(ssh host tar xf -)[/latex]
[latex]When are subshells created?[/latex]	[latex]A subshell is created implicitly for each command in a pipeline, or by explicitly using parentheses around a command e.g. \texttt{(cd /tmp | exit 1; date > timestamp)}[/latex]
[latex]What are command groups?[/latex]	[latex]Command groups allow a collection of commands to be considered as a whole with regard to redirection and control flow. They do nothing else, and can be thought of as ``null compound commands'' in that they they have no effect other than to group commands.\\e.g. \texttt{\{ echo ``Starting at \$(date)''; rsync -av . /backup; echo ``Finishing at \$(date)''; \} > backup.log 2>\&1}[/latex]
[latex]What does\\\texttt{for file; do; open ``\$file''; done} do?[/latex]	[latex]Equivalent to\\\texttt{for file in ``\$@''; do; open `\$file''; done}[/latex]
[latex]How do you define local variables in functions?[/latex]	[latex]With the local or declare keywords e.g.\\\texttt{\#!/bin/bash\\count() \{\\local i\\for ((i=1; i<=\$1; i++)); do echo \$i; done\\echo `Ah, ah, ah!'\\\} \\for ((i=1; i<=3; i++)); do count \$i; done.}\\The two \texttt{i} variables here do not interfere with each other.[/latex]
[latex]How do you remove an alias?[/latex]	[latex]With the \texttt{unalias} command.\\e.g.\ \texttt{unalias} ls[/latex]
[latex]How do you remove a variable or function?[/latex]	[latex]\texttt{unset -v and unset -f} e.g.\\\texttt{unset -f myfunction\\unset -v myvariable}[/latex]
[latex]How can you run a script that changes the environment of the calling script?[/latex]	[latex]Instead of running the script, you will need to source it (\texttt{source} or \texttt{.}). Otherwise the environment is reset to what it was before the script was run (with the exception of a few special parameters, like \$?)[/latex]
[latex]When is a job suspended?[/latex]	[latex]When its process group leader receives one of the signals \texttt{SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU}\@. \texttt{SIGTTIN} and \texttt{SIGTTOU} are automatically sent whenever a background job tries to read from or write to the terminal.[/latex]
[latex]With the default configuration of \texttt{stty}, what signals do \texttt{C-Z, C-C, C-\textbackslash} send?[/latex]	[latex]\begin{itemize}\item \texttt{Ctrl-Z} sends \texttt{SIGTSTP} to the foreground job (usually suspending it)\item \texttt{Ctrl-C} sends \texttt{SIGINT} to the foreground job (usually terminating it)\item \texttt{Ctrl-\textbackslash} sends \texttt{SIGQUIT} to the foreground job (usually causing it to dump core and abort)\end{itemize}[/latex]
[latex]What do \texttt{fg, bg, suspend, jobs, kill} and \texttt{disown} do?[/latex]	[latex]\begin{itemize}\item \texttt{fg [jobspec]:} bring a background job to the foreground\item \texttt{bg [jobspec \ldots]:} run a suspended job in the background.\item \texttt{suspend:} suspend the shell (mostly useful when the parent process is a shell with job control).\item \texttt{jobs [options] [jobspec \ldots]:} list suspened and background jobs. Options include -p (list process IDs only), -s (list only suspended jobs), and -r (list only running background jobs). If one or more jobspecs are specified, all other jobs are ignored.\item \texttt{kill} can take a jobspec instead of a process ID\item \texttt{disown} tells bash to forget about an existing job. This keeps bash from automatically sending \texttt{SIGHUP} to the processes in that job, but also means it can longer be referred to by jobspec.\end{itemize}[/latex]
[latex]What is a jobspec?[/latex]	[latex]A job specification or ``jobspec'' is a way of referring to the processes that make up a job. A jobspec may be \begin{itemize}\item\%n to refer to job number n.  \item\%str to refer to a job which was started by a command beginning with str. It is an error if there is more than one such job.  \item\%?str to refer to a job which was started by a command containing str. It is an error if there is more than one such job.  \item\%\%\% or \%+ to refer to the current job: the one most recently started in the background, or suspended from the foreground.\ fg and bg will operate on this job if no jobspec is given.  \item\%- for the previous job (the job that was \%\% before the current one).\end{itemize}[/latex]
